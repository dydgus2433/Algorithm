유기농 배추 문제 개인 풀이
====

###### 주의! 이 코드는 백준 온라인 저지 사이트에서 '런타임 에러' 결과를 받은 코드입니다.

이 문제 해결을 위해 차근차근 접근했다.
우선 배추를 심을 밭을 구현해야했다. 공부를 안하다보니 나는 이 곳에서도 잠시 고민해야했다.
동적할당으로 고차원의 배열을 만들어야했기 떄문이다.
정적할당처럼 bool field[X][y];로 만들어지지 않았다. 이의 해결법은 **'한 차원씩 만들기'**였다. [본인이 참고한 사이트. ~~별로 도움은 안된다~~](http://gshan85.tistory.com/34)
```cpp
int **field = new int*[X];
for (int i = 0; i < X; i++) {
	field[i] = new int[Y];
}

```
먼저 1차원 배열을 만들고, 하나하나에 다시 1차원 배열을 이어붙였다. 이로써 2차원 배열을 동적할당했다.

---
그런 다음에 본격적인 머리 짜내기가 시작되었다. '어떻게 해야 같은 블록인지를 확인할 수 있을까?'
형들이 얘기하던 너비우선탐색을 사용해야겠지? 등등 고민을 해보았다. ~~하지만 이내 타락하고 만다.~~

처음 구성할 때, field(밭)의 자료형은 bool형이었다. 순수하게 배추가 있다, 없다만의 정보를 담고 있었다.
하지만 나의 구성력으로는 다른 정보들이 많이 필요했고, 이를 한 곳에 담기 위해 int형으로 수정했다.

여기서 잠시, 밭의 정보에 대해 잠시 서술한다.
밭에 배추가 없다는 값은 '-1', 있다는 값은 '10000'이다.
배추가 있다는 신호는 1도 아니고 굳이 1만이라는 큰 수로 한 이유가 뭘까?

이유는 **벌레의 정보를 담기 위해서**이다. '0'이 차지하고 있는 숫자 4자리는 n번 벌레가 이 배추를 관리하고 있다는 정보를 담는데 쓰인다.
예를 들어, 1번 벌레가 관리하고 있는 배추의 값은 '10001'이 된다. (4자리를 벌레의 정보로 쓰는 이유는, 50x50제한 최대 벌레 수는 대략 1250이기 때문이다. ~~모자이크 생각하면 될듯~~)

이를 이용하여 ( A배추 : 이전에 벌레를 놓은 배추, B배추 : 지금 확인하고 있는 배추)
1. 배추를 발견했을 때마다 n번째 벌레를 투입한다. => B배추에 n번째 벌레 투입. B배추 값 = 10000 + n
2. B배추의 주변(상,하,좌,우) 배추를 확인하여 자기보다 먼저 투입된 벌레가 있다면 => 인접해있던 A배추의 값이 10000 + n보다 작다면
3. 방금 투입했던 n번째 벌레를 회수하고, B배추의 값을 A배추의 값과 동일하게 바꾼다. => n번째 벌레는 회수. B배추를 A배추의 벌레 영역으로 포함시킴.

이러한 방법으로 밭에 필요한 벌레의 갯수를 계산했다.
이 방법은 너비우선탐색에 비해 비효율적인 것들이 매우 많다. 우선 지나왔다, 안왔다에 상관없이 배추가 있는 곳이라면 그 배추에 벌레를 투입하고,
주변배추에 이미 벌레가 있는지를 항시 체크해야하며, 모든 벌레 투입이 완료된 이후에도 밭을 한 번 더 확인하여 마지막 벌레의 번호를 가져와야한다.

이런 비효율적임에도 불구하고 값을 구해냈다는 것은 잘한 것이오나, 좀 더 깔끔한 방법을 위해 공부해야겠다.

---
```cpp
#include <iostream>
#include <ctime>	// 시간을 이용하여 시드 배정을 하기 위해 추가
#include <cstdlib>	// rand() 사용을 위해 추가
#define NotFound -1	// 빈 땅임을 의미할 때.
#define Kimchi 10000// 김치(...) 배추가 이 땅에 있다는 의미의 임의의 값
using namespace std;

int main() {
	int X, Y, B;	// X는 가로, Y는 세로, B는 배추의 B.
	int x, y;	// 좌표를 가리킬 때 사용할 변수 (x,y)

	srand((unsigned int)time(NULL));	// 시드 배정

	int how_many;
	cin >> how_many;
	for (int a = 0; a < how_many; a++) {
		cin >> X >> Y >> B;

		// 동적으로 입력받은 밭의 크기만큼 동적할당. 2차원배열을 동적으로 생성한다.
		// 참고 사이트 : http://gshan85.tistory.com/34.
		// 1차원 배열을 가리키는 이중 포인터를 생성한 후, 생성된 포인터들로 다시 1차원 배열을 가리킨다.
		int **field = new int*[X];	// 밭을 가리킬 포인터 field. 가로 세로의 크기는 각각 1~50 제한
		for (int i = 0; i < X; i++) {
			field[i] = new int[Y];
		}


		/****** 밭의 초기화 밑 배추 심기 ******/

		for (int i = 0; i < X; i++) {
			for (int j = 0; j < Y; j++) {
				field[i][j] = NotFound;	// 밭의 모든 자리를 배추가 없다(404)로 초기화
			}
		}

		int c = 0;	// 심은 배추의 갯수를 세기 위해 사용할 변수.
		// 배추의 개수만큼, (x,y) 좌표를 뽑아내어 심는다.
		while (c < B) {
			x = rand() % X;
			y = rand() % Y;

			if (field[x][y] == NotFound) {	// (x,y)가 빈 땅이라면 (배추를 심지 않은 곳이라면)
				field[x][y] = Kimchi;	// 배추를 심고
				c++;	// 심은 갯수(변수 c)를 올려요.
				cout << x << ' ' << y << endl;	// 출력
			}
		}

		/****** 배추의 위치 파악 및 벌레 투입 ******/
		int bread = 1;	// 빵. 돌아올 길에 뿌려둘 변수(...)
		int worm = 0;	// 지렁이의 갯수.

		for (int i = 0; i < X; i++) {
			for (int j = 0; j < Y; j++) {
				if (field[i][j] >= Kimchi) {
					// 배추를 찾았을 경우
					worm++;	// 우선 벌레 갯수를 1개 증가
					field[i][j] += worm;	// 해당 배추에 벌레가 있음을 표시.

					if ((i != 0) && (field[i - 1][j] > Kimchi)) {
						// 찝은 지역의 좌측이 배추가 있는 지역이라면
						// 더 먼저 벌레를 넣은 쪽이 움직일 수 있는 곳임. 고로 넣은 벌레를 다시 빼줌
						if (field[i][j] > field[i - 1][j]) {
							field[i][j] = field[i - 1][j];
							worm--;
						}

						else {
							field[i - 1][j] = field[i][j];
						}
					}

					if (((i + 1) != X) && (field[i + 1][j] > Kimchi)) {
						// 찝은 지역의 우측이 배추가 있는 지역이라면
						// 더 먼저 벌레를 넣은 쪽이 움직일 수 있는 곳임. 고로 넣은 벌레를 다시 빼줌
						if (field[i][j] > field[i + 1][j]) {
							field[i][j] = field[i + 1][j];
							worm--;
						}

						else {
							field[i + 1][j] = field[i][j];
						}
					}

					if ((j != 0) && (field[i][j - 1] > Kimchi)) {
						// 찝은 지역의 윗측이 배추가 있는 지역이라면
						// 더 먼저 벌레를 넣은 쪽이 움직일 수 있는 곳임. 고로 넣은 벌레를 다시 빼줌
						if (field[i][j] > field[i][j - 1]) {
							field[i][j] = field[i][j - 1];
							worm--;
						}

						else {
							field[i][j - 1] = field[i][j];
						}
					}

					if (((j + 1) != 0) && (field[i][j + 1] > Kimchi)) {
						// 찝은 지역의 아랫측이 배추가 있는 지역이라면
						// 더 먼저 벌레를 넣은 쪽이 움직일 수 있는 곳임. 고로 넣은 벌레를 다시 빼줌
						if (field[i][j] > field[i][j + 1]) {
							field[i][j] = field[i][j + 1];
							worm--;
						}

						else {
							field[i][j] = field[i][j + 1];
						}
					}
				}
			}
		}

		int final_worm = 0;	// 초기값. 딱히 의미 없음

		for (int i = 0; i < X; i++) {
			for (int j = 0; j < Y; j++) {
				if ((field[i][j] != NotFound) && ((field[i][j] - Kimchi) > final_worm)) {
					// 빈 땅이 아니고, 배추 벌레의 번호가 가장 큰 것을 찾아냄
					final_worm = field[i][j] - Kimchi;
				}
			}
		}

		cout << final_worm << endl;	// 최종 벌레 수를 출력


		// 동적으로 할당한 2차원 배열(밭)을 반환. 삭제는 생성의 역순으로.
		for (int i = 0; i < X; i++) {
			delete[] field[i];
		}
		delete[] field;
	}

	return 0;
}
```
###### 이 코드는 문제를 제대로 읽지 않았으며, 조만간 repair 버전을 올릴 예정입니다.
